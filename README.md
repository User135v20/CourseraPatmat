Четвертое задание курса Functional Programming Principles in Scala (Scala 2 version) с сайта coursera.org.

В данном задании продожается знакомство с деревьями.

Кодирование Хаффмана - это алгоритм сжатия, который можно использовать для сжатия списков символов.
В обычном несжатом тексте каждый символ представлен одинаковым количеством битов (обычно восемью). 
В кодировании Хаффмана каждый символ может иметь битовое представление разной длины, в зависимости от того,
насколько распространен символ: символы, которые часто встречаются в тексте, представлены более короткой битовой
последовательностью, чем те, которые используются реже. Каждый код Хаффмана определяет конкретные битовые
последовательности, используемые для представления каждого символа. Код Хаффмана может быть представлен 
двоичным деревом, листья которого представляют символы, которые должны быть закодированы.

Пример дерева:  
______ / ______\  
____bea5 _____   cd9  
___ / _ \ ______ / _ \  
_ be2 _ a3 ____ c4 __ d5  
_/ _ \  
b1 _ e1  

Листья дерева содержат символ и частоту его использования, узлы содержат символы всех листьев и узлов ниже уровнем, число - сумма частоты использования символов.

Необходимо реализовать функции, которые позволят создавать такие деревья по входному массиву символов, а так же кодировать и декодировать текст, согласно дереву.  

Кодирование происходит следующим образом: исходная позиция -- корень дерева, 0 - ветвь влево, 1 -- вправо, пока не дойдет до листа.  

Перед каждой функцией есть небольшое описание\требование, в файле Huffman.scala
HuffmanSuite.scala - содержит набор тестов.
